# ccp <- solution$ccp
# cbind(nu[1:10],condval[1:10,])
# Implied CCPs for each **data point**
ccp_1b <- matrix(ccp_1[busdata$data_x_index], ncol=ncol(busdata$data_x_index))
# Actual decisions for each point
data_d <- busdata$data_d
## Coding check: return same probability of repair?
#ave_ccp <- mean(ccp_1b[, -ncol(ccp_1b)])
#erp <- -(mean(data_d[, -ncol(data_d)])-2)
#disp( c(ave_ccp,erp) )
# Minimize this (negative) log-likelihood
#  - Note the t=T data where we don't have decisions are zeroed out from this
logL <- - sum (  (data_d==1)*log(ccp_1b) + (data_d==2)*log(1-ccp_1b))
# Finishing
return(logL)
}
u2_theta <- function(theta, x) {
theta[1] + theta[2] * x
}
objective <- function(theta, u2_hat, x, W) {
u2_model <- u2_theta(theta, x)  # Model-implied utility for "no repair"
diff <- matrix(u2_model - u2_hat, ncol = 1)  # Ensure it's a column vector
return(t(diff) %*% W %*% diff)  # Weighted quadratic loss
}
calculate_weighting_matrix <- function(F1, F2, beta, x_len) {
#calculate total how many times does each state appear within the data
states_used <- as.vector(data_x_index)
state_counts <- table(factor(states_used, levels = 1:x_len))
weight_vector <- as.numeric(state_counts) / length(states_used)
W <- diag(weight_vector)
return(W)
}
minimum_distance_estimator<- function(F1,F2,beta,ccp_hat,x_len){
#estimate the unrestricted utility of not replacing the engine for each state
gamma <- 0.5772  # actually it is not needed. It cancels out
Psi1 <- gamma - log(ccp_hat)
Psi2 <- gamma - log(1-ccp_hat)
u1 <- rep(0, x_len)  # utility for choice 1 set to 0
I <- diag(x_len)
inv_term <- solve(I - beta * F1)
u2_hat <- Psi1-Psi2 - u1 + beta * (F1 - F2) %*% inv_term %*% (Psi1 + u1)
#calculate the weighting matrix
W<- calculate_weighting_matrix(F1, F2, beta, x_len)
#initial_theta <- c(1, -0.1)
# initial guess for theta
#minimize the weighted squared deviation
result <- optim(par = c(1.5, -4),
fn = objective,
u2_hat = u2_hat,
x = x,
W = W)
theta_hat <- result$par
return(theta_hat)
}
objective_per_observation <- function(theta, u2_hat, data_x_index) {
# data_x_index: vector of observed states, length = N_obs
# Map from observed states to estimated u2_hat for that state
u2_hat_obs <- u2_hat[data_x_index]
# Compute model utility at the observed x values
x_obs <- data_x_index
u2_model_obs <- u2_theta(theta, x_obs)
# Moment differences: one per observation
diff <- u2_model_obs - u2_hat_obs
# Identity weighting: unweighted sum of squares
return(sum(diff^2))
}
minimum_distance_estimator_per_observation <- function(F1, F2, beta, ccp_hat, x_len, data_x_index) {
# Estimate unrestricted utility
gamma <- 0.5772
Psi1 <- gamma - log(ccp_hat)
Psi2 <- gamma - log(1 - ccp_hat)
u1 <- rep(0, x_len)
I <- diag(x_len)
inv_term <- solve(I - beta * F1)
u2_hat <- Psi1 - Psi2 - u1 + beta * (F1 - F2) %*% inv_term %*% (Psi1 + u1)
u2_hat <- as.vector(u2_hat)  # Ensure it's a vector
# Run optimization using identity weighting matrix (i.e. no W needed explicitly)
result <- optim(
par = c(1.5, -4),
fn = objective_per_observation,
u2_hat = u2_hat,
data_x_index = data_x_index
)
theta_hat <- result$par
return(theta_hat)
}
theta_hat <- minimum_distance_estimator(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len)
# Print the estimated parameters
print(theta_hat)
theta_hat <- minimum_distance_estimator_per_observation(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len, data_x_index=data_x_index)
print(theta_hat)
source("~/Documents/GitHub/structural models/Structural_Models/thirdQuestion/ccp_r_functions.R")
################################################################################
# This function performs a value function contraction mapping.
#
# Inputs include:
#   - flow: matrix with flow payoffs for each mileage (row) and action (column)
#   - F1: mileage transition if action=1 (repair)
#   - F2: mileage transition if action=2 (don't repair)
#   - X: possible mileage
#   - beta: discount factor
#
# Outputs include:
#   - condval: conditional values that satisfy contraction mapping
#   - iter: number of iterations done in contraction (curiosity)
#   - ccp: implied choice probability for action=1 (repair)
#
# This is used for FIML estimation and data generation
################################################################################
valuemap <- function(flow,F1,F2,X,beta){
# Candidate value conditional value functions: rows are state; columns are choice
v0 <- matrix(0,length(X),2)
# Euler's constant. Not needed but allows condition value function to have
# same units as the ex ante value function of Hotz-Miller so adding for
# better comparability
euler <- 0.5772
# Solving the contraction mapping
value_diff <- 1
iter <- 0
while ( value_diff > 1e-5 && iter<1000){
# Implied inclusive value given state
ival <- log( rowSums(exp(v0))) + euler
# Implied expectation of next period's value, by decision
expval <- cbind(F1%*%ival,F2%*%ival)
# Implied conditional values
v1 <- flow + beta*expval
# Maximum gap
value_diff <- max(abs(v0-v1))
# Update
v0 <- v1
}
if (value_diff > 1e-5){print("Contraction Mapping Fails")}
# Conditional Choice Probability (CCP): probability that choose repair (d=1)
ccp <- 1 / (1 + exp(v0[,2] - v0[,1]))
return(list(condval=v0,iter=iter,ccp=ccp))
}
################################################################################
# This function generates a sample of N buses observed over T years
#
# Inputs include:
#   - F1: mileage transition if action=1 (repair)
#   - F2: mileage transition if action=2 (don't repair)
#   - F2b: a CDF version of F2
#   - X: possible mileage
#   - theta: payoff parameters
#   - beta: discount factor
#
# Outputs include:
#   - data_x: mileages for buses (rows) and periods (columns)
#   - data_d: actions for buses (rows) and periods (columns); =1 for repair, =2 otherwise
#   - data_x_index: useful index
#
# This provides the data used in estimation
################################################################################
generate_data <- function(N,T,F1,F2,F2b,X,theta,beta) {
initial_run <- 5
x_index <- matrix(1, nrow = N, ncol = T + initial_run)
# Decisions and mileage to be filled in
d_sim <- matrix(0, nrow = N, ncol = T + initial_run)
x_sim <- matrix(0, nrow = N, ncol = T + initial_run)
# Random draws to translate probabilities into decisions and mileage transition
draw_d <- matrix(runif(N * (T + initial_run)), nrow = N)
draw_x <- matrix(runif(N * (T + initial_run)), nrow = N)
# Flow utility.
# - rows are state; columns are choice (1=repair, 2=no repair)
flow = cbind( rep(0,length(X)), theta[1] +theta[2]*X )
# Obtaining conditional value function and implied CCP.
# - rows are state; columns are choice (1=repair, 2=no repair)
solution <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)
condval <- solution$condval
ccp <- solution$ccp
for (n in 1:N) {
for (t in 1:(T + initial_run - 1)) {
# Probability of "repair" and "don't repair"
p1 <- ccp[x_index[n,t]]
# Use random draws; =1 if "repair" and =2 if "don't repair"
d_sim[n, t] <- (draw_d[n, t] > p1) + 1
# If don't repair, transition to a new mileage state based on random draw
x_index[n, t + 1] <- (d_sim[n, t] == 2) * sum(draw_x[n,t] > F2b[x_index[n, t], ]) + 1
# Recording the implied mileage from that transition
x_sim[n, t + 1] <- X[x_index[n, t + 1]]
}
}
data_x <- x_sim[, (initial_run + 1):(T + initial_run)]
data_d <- d_sim[, (initial_run + 1):(T + initial_run)]
data_t <- t(matrix(rep(1:T, N), nrow = T))
data_x_index <- apply(data_x, 2, function(col) match(col, X))
return(list(data_t = data_t, data_x = data_x, data_d = data_d, data_x_index = data_x_index))
}
################################################################################
# This function obtain the log-likelihood for FIML (Rust-style full information
# value function interation)
#
# Inputs include:
#   - theta_cand: candidate payoff parameters
#   - busdata: data on buses
#   - F1: mileage transition if action=1 (repair)
#   - F2: mileage transition if action=2 (don't repair)
#   - X: possible mileage
#   - beta: discount factor
#
# Outputs include:
#   - logL: (negative) log-likelihood function
#
################################################################################
f_FIML <- function(theta_cand,busdata,F1,F2,X,beta){
#print(theta_cand)
# Conditional flow utility at every state
flow <- cbind( rep(0,length(X)), theta_cand[1] +theta_cand[2]*X)
# Contraction mapping: Conditional value functions, CCPs at every *state*
solution <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)
condval <- solution$condval
ccp <- solution$ccp
# CCPS for each *data point*
p1 <- matrix(ccp[busdata$data_x_index], ncol=ncol(busdata$data_x_index))
# Actual decisions for each point
data_d <- busdata$data_d
## Coding check: similar probabilities of repair?
#emp_ccp <- matrix(ccp[data_x_index], ncol=ncol(data_x_index))
#ave_ccp <- mean(emp_ccp[, -ncol(emp_ccp)])
#erp <- -(mean(data_d[, -ncol(data_d)])-2)
#disp( c(ave_ccp,erp) )
# Minimize this (negative) log-likelihood
#  - Note the t=T data where we don't have decisions are zeroed out from this
logL <- - sum (  (data_d==1)*log(p1) + (data_d==2)*log(1-p1))
# Finishing
return(logL)
}
################################################################################
# This function obtains the log-likelihood for Hotz-Miller-style CCP estimation
#
# Inputs include:
#   - theta_cand: candidate payoff parameters
#   - busdata: data on buses
#   - F1: mileage transition if action=1 (repair)
#   - F2: mileage transition if action=2 (don't repair)
#   - X: possible mileage
#   - beta: discount factor
#   - ccp_hat: pre-estimated CCPs
#
# Outputs include:
#   - logL: (negative) log-likelihood function
#
################################################################################
f_CCP_EST <- function(theta_cand,busdata,F1,F2,X,beta,ccp_hat){
#print(theta_cand)
# Working on numerator--in state space--this is an N*1 vector
euler <- 0.5772
phat1 <- ccp_hat
phat2 <- 1-phat1
flow2 <- theta_cand[1] + theta_cand[2]*X
numer <- phat1*(0-log(phat1)) + phat2*(flow2-log(phat2)) + euler
# Working on denominator--in state space--this needs to be an N*N matrix
eyeN <- diag(length(X))
phat1_tile <- t(matrix(rep(phat1, each = length(phat1)), ncol = length(phat1)))
phat2_tile <- 1 - phat1_tile
denom <- eyeN - beta*phat1_tile*F1 - beta*phat2_tile*F2
# Implied ex ante value function--one value per state--N*1 vector
nu <- solve(denom)%*%numer
# Convert to implied CCPs
term1 <- 0 + beta*F1%*%nu
term2 <- flow2 + beta*F2%*%nu
ccp_1 <- exp(term1) / (exp(term1) + exp(term2))
## Coding check: if ccp_hat = true ccp then these should be identical
#cbind(ccp_1,ccp_hat)[1:10,]
## Coding check: The ex ante value is a bit larger than conditional values
# flow = cbind( rep(0,length(X)), theta_cand[1] +theta_cand[2]*X)
# solution <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)
# condval <- solution$condval
# ccp <- solution$ccp
# cbind(nu[1:10],condval[1:10,])
# Implied CCPs for each **data point**
ccp_1b <- matrix(ccp_1[busdata$data_x_index], ncol=ncol(busdata$data_x_index))
# Actual decisions for each point
data_d <- busdata$data_d
## Coding check: return same probability of repair?
#ave_ccp <- mean(ccp_1b[, -ncol(ccp_1b)])
#erp <- -(mean(data_d[, -ncol(data_d)])-2)
#disp( c(ave_ccp,erp) )
# Minimize this (negative) log-likelihood
#  - Note the t=T data where we don't have decisions are zeroed out from this
logL <- - sum (  (data_d==1)*log(ccp_1b) + (data_d==2)*log(1-ccp_1b))
# Finishing
return(logL)
}
u2_theta <- function(theta, x) {
theta[1] + theta[2] * x
}
objective <- function(theta, u2_hat, x, W) {
u2_model <- u2_theta(theta, x)  # Model-implied utility for "no repair"
diff <- matrix(u2_model - u2_hat, ncol = 1)  # Ensure it's a column vector
return(t(diff) %*% W %*% diff)  # Weighted quadratic loss
}
calculate_weighting_matrix <- function(F1, F2, beta, x_len) {
#calculate total how many times does each state appear within the data
states_used <- as.vector(data_x_index)
state_counts <- table(factor(states_used, levels = 1:x_len))
weight_vector <- as.numeric(state_counts) / length(states_used)
W <- diag(weight_vector)
return(W)
}
minimum_distance_estimator<- function(F1,F2,beta,ccp_hat,x_len){
#estimate the unrestricted utility of not replacing the engine for each state
gamma <- 0.5772  # actually it is not needed. It cancels out
Psi1 <- gamma - log(ccp_hat)
Psi2 <- gamma - log(1-ccp_hat)
u1 <- rep(0, x_len)  # utility for choice 1 set to 0
I <- diag(x_len)
inv_term <- solve(I - beta * F1)
u2_hat <- Psi1-Psi2 - u1 + beta * (F1 - F2) %*% inv_term %*% (Psi1 + u1)
#calculate the weighting matrix
W<- calculate_weighting_matrix(F1, F2, beta, x_len)
#initial_theta <- c(1, -0.1)
# initial guess for theta
#minimize the weighted squared deviation
result <- optim(par = c(1.5, -4),
fn = objective,
u2_hat = u2_hat,
x = x,
W = W)
theta_hat <- result$par
return(theta_hat)
}
objective_per_observation <- function(theta, u2_hat, data_x_index) {
# data_x_index: vector of observed states, length = N_obs
# Map from observed states to estimated u2_hat for that state
u2_hat_obs <- u2_hat[data_x_index]
print(paste("u2_hat_obs:", paste(u2_hat_obs, collapse = ", ")))
# Compute model utility at the observed x values
x_obs <- data_x_index
u2_model_obs <- u2_theta(theta, x_obs)
# Moment differences: one per observation
diff <- u2_model_obs - u2_hat_obs
# Identity weighting: unweighted sum of squares
return(sum(diff^2))
}
minimum_distance_estimator_per_observation <- function(F1, F2, beta, ccp_hat, x_len, data_x_index) {
# Estimate unrestricted utility
gamma <- 0.5772
Psi1 <- gamma - log(ccp_hat)
Psi2 <- gamma - log(1 - ccp_hat)
u1 <- rep(0, x_len)
I <- diag(x_len)
inv_term <- solve(I - beta * F1)
u2_hat <- Psi1 - Psi2 - u1 + beta * (F1 - F2) %*% inv_term %*% (Psi1 + u1)
u2_hat <- as.vector(u2_hat)  # Ensure it's a vector
# Run optimization using identity weighting matrix (i.e. no W needed explicitly)
result <- optim(
par = c(1.5, -4),
fn = objective_per_observation,
u2_hat = u2_hat,
data_x_index = data_x_index
)
theta_hat <- result$par
return(theta_hat)
}
theta_hat <- minimum_distance_estimator_per_observation(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len, data_x_index=data_x_index)
print(theta_hat)
source("~/Documents/GitHub/structural models/Structural_Models/thirdQuestion/ccp_r_functions.R")
################################################################################
# Translation of the MATLAB code on CCP estimation.
# This translation was originally authored by
# Nathan Miller, with contributions by Ryan Mansley, Tianshi Mu, and Gretchen Sileo
#
# The code implements a FIML (Rust 1987) estimation algorithm and a CCP-based approach.
################################################################################
rm(list = ls())  # Clear the workspace
set.seed(12)     # Set the random seed
path <- "~/Documents/GitHub/structural models/Structural_Models/thirdQuestion"
setwd(path)
#Read the relevant libraries
source("ccp_r_functions.R")
library(ggplot2)
library(dplyr)
options(scipen = 999)
#########################################################################
# Defining the states: mileage
# - x_min and x_max give the min and max mileage is 0 and the max is 15
# - delta_x is for discretizing the space
# - x_len gives the number of discrete states, which is 301
# - x is a vector of the states
#########################################################################
x_min <- 0.0
x_max <- 15.0
delta_x <- 0.05
x_len <- (x_max - x_min) / delta_x + 1
x <- seq(x_min, x_max, by = delta_x)
#########################################################################
# Defining the state transitions
# - F1, F2 has starting state as row i ; ending state as column k
# - Builds in assumptions on how these transitions occur
# - F2 is the transition that occurs **without** replacement
# - F1 is the transition that occurs **with** replacement and is simpler
# - F2b is like F2 but it is the *CDF* not the PDF of the transition distribution
# - Saving Euler's constant for now
#########################################################################
x_tday <- matrix(rep(x, each = x_len), nrow = x_len)
x_next <- t(x_tday)
f <- (x_next >= x_tday) * exp(- (x_next - x_tday)) * (1 - exp(-delta_x))
f <- t(f)
f[, ncol(f)] <- 1 - rowSums(f[, 1:(ncol(f) - 1)])
F2 <- f
F2b <- t(apply(f, 1, cumsum))
F1 <- matrix(0, nrow = nrow(f), ncol = ncol(f))
F1[, 1] <- 1
#########################################################################
# Parameterization
# - beta: Discount factor
# - theta: theta[1] = base utility of "not repair" (+),
#          theta[2] = utility of "not repair" decreases with mileage (-)
# - T: let this play out over T time periods
# - N: number of buses
#########################################################################
beta <- 0.9
theta <- c(2.00, -0.15)
T <- 30
X <- x
N <- 2000
#test
flow = cbind( rep(0,length(X)), theta[1] + theta[2]*X )
condval <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)$condval
ccp <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)$ccp
condval[1:10,]
#########################################################################
# Generating data and plotting for Bus 1 for confirmation
# - N buses observed over T periods each
# - Check that average CCP corresponds to average decision
# - Plot data for Bus 1, t=1,...15, to see whether it is reasonable
#########################################################################
busdata <- generate_data(N=N,T=T,F1=F1,F2=F2,F2b=F2b,X=X,theta=theta,beta=beta)
data_t <- busdata$data_t
data_x <- busdata$data_x
data_d <- busdata$data_d
data_x_index <- busdata$data_x_index
# Average CCP vs. empirical repair percentage [EPR = -(ave-2)) ]
# These line up ... **must exclude t=T as no decision is recorded there**
emp_ccp <- matrix(ccp[data_x_index], ncol=ncol(data_x_index))
ave_ccp <- mean(emp_ccp[, -ncol(emp_ccp)])
erp <- -(mean(data_d[, -ncol(data_d)])-2)
print(c(ave_ccp, erp))
#########################################################################
# Estimating with Full Solution, Value Function Iteration (FIML)
#########################################################################
# Starting values
theta_cand <- theta
# Will impose bounds to avoid extreme parameters
theta_cand_lower <- c(1, -0.20)
theta_cand_upper <- c(3, -0.10)
# Converges to lower bounds
opt_FIML <- optim(theta_cand*0.9, f_FIML, busdata=busdata, F1=F1, F2=F2, X=X, beta=beta,
method = "L-BFGS-B", lower = theta_cand_lower, upper = theta_cand_upper)
print(opt_FIML)
# Evaluating objective function for visual on convergence
f_FIML(theta=theta*0.8,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*0.9,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*1.0,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*1.1,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*1.2,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
#########################################################################
# Estimating with CCPs
#########################################################################
# Prepare the data for logit regression
logitdata <- as.data.frame(cbind((c(data_d)==1), c(data_x), c(data_x)^2))
names(logitdata) <- c("repair","mileage","mileage2")
# Estimate the logit model
logitres <- glm(repair ~ mileage + mileage2, family = binomial(link = "logit"), data = logitdata)
logitpar <- logitres$coef
# Predicted values for each state
#temp <- logitpar[1] + logitpar[2]*X
temp <- logitpar[1] + logitpar[2]*X + logitpar[3]*X^2
ccp_hat <- exp(temp) / (1+exp(temp))
# True CCPs
flow = cbind( rep(0,length(X)), theta[1] +theta[2]*(0:(length(X)-1)) )
ccp_tru <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)$ccp
# Starting values
theta_cand <- theta
# Will impose bounds to avoid extreme parameters
theta_cand_lower <- c(1, -0.20)
theta_cand_upper <- c(3, -0.10)
# Converges to lower bounds
opt_CCP <- optim(theta_cand, f_CCP_EST, busdata=busdata, F1=F1, F2=F2, X=X, beta=beta, ccp_hat=ccp_hat,
method = "L-BFGS-B", lower = theta_cand_lower, upper = theta_cand_upper)
print(opt_CCP)
# Evaluating objective function for visual on convergence
f_CCP_EST(theta_cand=theta*0.8,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*0.9,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*1.0,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*1.1,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*1.2,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
##########################################################################
# here we start with the code for question 3
theta_hat <- minimum_distance_estimator(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len)
# Print the estimated parameters
print(theta_hat)
theta_hat <- minimum_distance_estimator_per_observation(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len, data_x_index=data_x_index)
print(theta_hat)
View(logitdata)
source("~/Documents/GitHub/structural models/Structural_Models/thirdQuestion/ccp_r_functions.R")
objective_per_observation <- function(theta, u2_hat, data_x_index) {
# data_x_index: vector of observed states, length = N_obs
# Map from observed states to estimated u2_hat for that state
u2_hat_obs <- u2_hat[data_x_index]
print(length(u2_hat_obs))  # Debugging: check length of u2_hat_obs)
# Compute model utility at the observed x values
x_obs <- data_x_index
u2_model_obs <- u2_theta(theta, x_obs)
# Moment differences: one per observation
diff <- u2_model_obs - u2_hat_obs
# Identity weighting: unweighted sum of squares
return(t(diff) %*% diff)  # Weighted quadratic loss
}
theta_hat <- minimum_distance_estimator_per_observation(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len, data_x_index=data_x_index)
