X <- x
N <- 2000
#test
flow = cbind( rep(0,length(X)), theta[1] + theta[2]*X )
condval <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)$condval
ccp <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)$ccp
condval[1:10,]
#########################################################################
# Generating data and plotting for Bus 1 for confirmation
# - N buses observed over T periods each
# - Check that average CCP corresponds to average decision
# - Plot data for Bus 1, t=1,...15, to see whether it is reasonable
#########################################################################
busdata <- generate_data(N=N,T=T,F1=F1,F2=F2,F2b=F2b,X=X,theta=theta,beta=beta)
data_t <- busdata$data_t
data_x <- busdata$data_x
data_d <- busdata$data_d
data_x_index <- busdata$data_x_index
# Average CCP vs. empirical repair percentage [EPR = -(ave-2)) ]
# These line up ... **must exclude t=T as no decision is recorded there**
emp_ccp <- matrix(ccp[data_x_index], ncol=ncol(data_x_index))
ave_ccp <- mean(emp_ccp[, -ncol(emp_ccp)])
erp <- -(mean(data_d[, -ncol(data_d)])-2)
print(c(ave_ccp, erp))
#########################################################################
# Estimating with Full Solution, Value Function Iteration (FIML)
#########################################################################
# Starting values
theta_cand <- theta
# Will impose bounds to avoid extreme parameters
theta_cand_lower <- c(1, -0.20)
theta_cand_upper <- c(3, -0.10)
# Converges to lower bounds
opt_FIML <- optim(theta_cand*0.9, f_FIML, busdata=busdata, F1=F1, F2=F2, X=X, beta=beta,
method = "L-BFGS-B", lower = theta_cand_lower, upper = theta_cand_upper)
print(opt_FIML)
# Evaluating objective function for visual on convergence
f_FIML(theta=theta*0.8,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*0.9,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*1.0,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*1.1,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*1.2,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
#########################################################################
# Estimating with CCPs
#########################################################################
# Prepare the data for logit regression
logitdata <- as.data.frame(cbind((c(data_d)==1), c(data_x), c(data_x)^2))
names(logitdata) <- c("repair","mileage","mileage2")
# Estimate the logit model
logitres <- glm(repair ~ mileage + mileage2, family = binomial(link = "logit"), data = logitdata)
logitpar <- logitres$coef
# Predicted values for each state
#temp <- logitpar[1] + logitpar[2]*X
temp <- logitpar[1] + logitpar[2]*X + logitpar[3]*X^2
ccp_hat <- exp(temp) / (1+exp(temp))
# True CCPs
flow = cbind( rep(0,length(X)), theta[1] +theta[2]*(0:(length(X)-1)) )
ccp_tru <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)$ccp
# Starting values
theta_cand <- theta
# Will impose bounds to avoid extreme parameters
theta_cand_lower <- c(1, -0.20)
theta_cand_upper <- c(3, -0.10)
# Converges to lower bounds
opt_CCP <- optim(theta_cand, f_CCP_EST, busdata=busdata, F1=F1, F2=F2, X=X, beta=beta, ccp_hat=ccp_hat,
method = "L-BFGS-B", lower = theta_cand_lower, upper = theta_cand_upper)
print(opt_CCP)
# Evaluating objective function for visual on convergence
f_CCP_EST(theta_cand=theta*0.8,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*0.9,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*1.0,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*1.1,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*1.2,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
##########################################################################
# here we start with the code for question 3
theta_hat <- minimum_distance_estimator(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len)
print(theta_hat)
minimum_distance_estimator<- function(F1,F2,beta,ccp_hat,x_len){
print("Running minimum distance estimator")
}
################################################################################
# Translation of the MATLAB code on CCP estimation.
# This translation was originally authored by
# Nathan Miller, with contributions by Ryan Mansley, Tianshi Mu, and Gretchen Sileo
#
# The code implements a FIML (Rust 1987) estimation algorithm and a CCP-based approach.
################################################################################
rm(list = ls())  # Clear the workspace
set.seed(12)     # Set the random seed
#Set your working directory:
path <- "~/Documents/GitHub/structural models"
setwd(path)
#Read the relevant libraries
source("ccp_r_functions.R")
library(ggplot2)
library(dplyr)
options(scipen = 999)
#########################################################################
# Defining the states: mileage
# - x_min and x_max give the min and max mileage is 0 and the max is 15
# - delta_x is for discretizing the space
# - x_len gives the number of discrete states, which is 301
# - x is a vector of the states
#########################################################################
x_min <- 0.0
x_max <- 15.0
delta_x <- 0.05
x_len <- (x_max - x_min) / delta_x + 1
x <- seq(x_min, x_max, by = delta_x)
#########################################################################
# Defining the state transitions
# - F1, F2 has starting state as row i ; ending state as column k
# - Builds in assumptions on how these transitions occur
# - F2 is the transition that occurs **without** replacement
# - F1 is the transition that occurs **with** replacement and is simpler
# - F2b is like F2 but it is the *CDF* not the PDF of the transition distribution
# - Saving Euler's constant for now
#########################################################################
x_tday <- matrix(rep(x, each = x_len), nrow = x_len)
x_next <- t(x_tday)
f <- (x_next >= x_tday) * exp(- (x_next - x_tday)) * (1 - exp(-delta_x))
f <- t(f)
f[, ncol(f)] <- 1 - rowSums(f[, 1:(ncol(f) - 1)])
F2 <- f
F2b <- t(apply(f, 1, cumsum))
F1 <- matrix(0, nrow = nrow(f), ncol = ncol(f))
F1[, 1] <- 1
#########################################################################
# Parameterization
# - beta: Discount factor
# - theta: theta[1] = base utility of "not repair" (+),
#          theta[2] = utility of "not repair" decreases with mileage (-)
# - T: let this play out over T time periods
# - N: number of buses
#########################################################################
beta <- 0.9
theta <- c(2.00, -0.15)
T <- 30
X <- x
N <- 2000
#test
flow = cbind( rep(0,length(X)), theta[1] + theta[2]*X )
condval <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)$condval
ccp <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)$ccp
condval[1:10,]
#########################################################################
# Generating data and plotting for Bus 1 for confirmation
# - N buses observed over T periods each
# - Check that average CCP corresponds to average decision
# - Plot data for Bus 1, t=1,...15, to see whether it is reasonable
#########################################################################
busdata <- generate_data(N=N,T=T,F1=F1,F2=F2,F2b=F2b,X=X,theta=theta,beta=beta)
data_t <- busdata$data_t
data_x <- busdata$data_x
data_d <- busdata$data_d
data_x_index <- busdata$data_x_index
# Average CCP vs. empirical repair percentage [EPR = -(ave-2)) ]
# These line up ... **must exclude t=T as no decision is recorded there**
emp_ccp <- matrix(ccp[data_x_index], ncol=ncol(data_x_index))
ave_ccp <- mean(emp_ccp[, -ncol(emp_ccp)])
erp <- -(mean(data_d[, -ncol(data_d)])-2)
print(c(ave_ccp, erp))
#########################################################################
# Estimating with Full Solution, Value Function Iteration (FIML)
#########################################################################
# Starting values
theta_cand <- theta
# Will impose bounds to avoid extreme parameters
theta_cand_lower <- c(1, -0.20)
theta_cand_upper <- c(3, -0.10)
# Converges to lower bounds
opt_FIML <- optim(theta_cand*0.9, f_FIML, busdata=busdata, F1=F1, F2=F2, X=X, beta=beta,
method = "L-BFGS-B", lower = theta_cand_lower, upper = theta_cand_upper)
print(opt_FIML)
# Evaluating objective function for visual on convergence
f_FIML(theta=theta*0.8,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*0.9,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*1.0,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*1.1,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*1.2,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
#########################################################################
# Estimating with CCPs
#########################################################################
# Prepare the data for logit regression
logitdata <- as.data.frame(cbind((c(data_d)==1), c(data_x), c(data_x)^2))
names(logitdata) <- c("repair","mileage","mileage2")
# Estimate the logit model
logitres <- glm(repair ~ mileage + mileage2, family = binomial(link = "logit"), data = logitdata)
logitpar <- logitres$coef
# Predicted values for each state
#temp <- logitpar[1] + logitpar[2]*X
temp <- logitpar[1] + logitpar[2]*X + logitpar[3]*X^2
ccp_hat <- exp(temp) / (1+exp(temp))
# True CCPs
flow = cbind( rep(0,length(X)), theta[1] +theta[2]*(0:(length(X)-1)) )
ccp_tru <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)$ccp
# Starting values
theta_cand <- theta
# Will impose bounds to avoid extreme parameters
theta_cand_lower <- c(1, -0.20)
theta_cand_upper <- c(3, -0.10)
# Converges to lower bounds
opt_CCP <- optim(theta_cand, f_CCP_EST, busdata=busdata, F1=F1, F2=F2, X=X, beta=beta, ccp_hat=ccp_hat,
method = "L-BFGS-B", lower = theta_cand_lower, upper = theta_cand_upper)
print(opt_CCP)
# Evaluating objective function for visual on convergence
f_CCP_EST(theta_cand=theta*0.8,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*0.9,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*1.0,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*1.1,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*1.2,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
##########################################################################
# here we start with the code for question 3
theta_hat <- minimum_distance_estimator(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len)
print(theta_hat)
theta_hat <- c(0,0)
theta_hat <- minimum_distance_estimator(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len)
print(theta_hat)
################################################################################
# Translation of the MATLAB code on CCP estimation.
# This translation was originally authored by
# Nathan Miller, with contributions by Ryan Mansley, Tianshi Mu, and Gretchen Sileo
#
# The code implements a FIML (Rust 1987) estimation algorithm and a CCP-based approach.
################################################################################
rm(list = ls())  # Clear the workspace
set.seed(12)     # Set the random seed
path <- "~/Documents/GitHub/structural models/thirdQuestion"
setwd(path)
#Read the relevant libraries
source("ccp_r_functions.R")
library(ggplot2)
library(dplyr)
options(scipen = 999)
#########################################################################
# Defining the states: mileage
# - x_min and x_max give the min and max mileage is 0 and the max is 15
# - delta_x is for discretizing the space
# - x_len gives the number of discrete states, which is 301
# - x is a vector of the states
#########################################################################
x_min <- 0.0
x_max <- 15.0
delta_x <- 0.05
x_len <- (x_max - x_min) / delta_x + 1
x <- seq(x_min, x_max, by = delta_x)
#########################################################################
# Defining the state transitions
# - F1, F2 has starting state as row i ; ending state as column k
# - Builds in assumptions on how these transitions occur
# - F2 is the transition that occurs **without** replacement
# - F1 is the transition that occurs **with** replacement and is simpler
# - F2b is like F2 but it is the *CDF* not the PDF of the transition distribution
# - Saving Euler's constant for now
#########################################################################
x_tday <- matrix(rep(x, each = x_len), nrow = x_len)
x_next <- t(x_tday)
f <- (x_next >= x_tday) * exp(- (x_next - x_tday)) * (1 - exp(-delta_x))
f <- t(f)
f[, ncol(f)] <- 1 - rowSums(f[, 1:(ncol(f) - 1)])
F2 <- f
F2b <- t(apply(f, 1, cumsum))
F1 <- matrix(0, nrow = nrow(f), ncol = ncol(f))
F1[, 1] <- 1
#########################################################################
# Parameterization
# - beta: Discount factor
# - theta: theta[1] = base utility of "not repair" (+),
#          theta[2] = utility of "not repair" decreases with mileage (-)
# - T: let this play out over T time periods
# - N: number of buses
#########################################################################
beta <- 0.9
theta <- c(2.00, -0.15)
T <- 30
X <- x
N <- 2000
#test
flow = cbind( rep(0,length(X)), theta[1] + theta[2]*X )
condval <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)$condval
ccp <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)$ccp
condval[1:10,]
#########################################################################
# Generating data and plotting for Bus 1 for confirmation
# - N buses observed over T periods each
# - Check that average CCP corresponds to average decision
# - Plot data for Bus 1, t=1,...15, to see whether it is reasonable
#########################################################################
busdata <- generate_data(N=N,T=T,F1=F1,F2=F2,F2b=F2b,X=X,theta=theta,beta=beta)
data_t <- busdata$data_t
data_x <- busdata$data_x
data_d <- busdata$data_d
data_x_index <- busdata$data_x_index
# Average CCP vs. empirical repair percentage [EPR = -(ave-2)) ]
# These line up ... **must exclude t=T as no decision is recorded there**
emp_ccp <- matrix(ccp[data_x_index], ncol=ncol(data_x_index))
ave_ccp <- mean(emp_ccp[, -ncol(emp_ccp)])
erp <- -(mean(data_d[, -ncol(data_d)])-2)
print(c(ave_ccp, erp))
#########################################################################
# Estimating with Full Solution, Value Function Iteration (FIML)
#########################################################################
# Starting values
theta_cand <- theta
# Will impose bounds to avoid extreme parameters
theta_cand_lower <- c(1, -0.20)
theta_cand_upper <- c(3, -0.10)
# Converges to lower bounds
opt_FIML <- optim(theta_cand*0.9, f_FIML, busdata=busdata, F1=F1, F2=F2, X=X, beta=beta,
method = "L-BFGS-B", lower = theta_cand_lower, upper = theta_cand_upper)
print(opt_FIML)
# Evaluating objective function for visual on convergence
f_FIML(theta=theta*0.8,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*0.9,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*1.0,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*1.1,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
f_FIML(theta=theta*1.2,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta)
#########################################################################
# Estimating with CCPs
#########################################################################
# Prepare the data for logit regression
logitdata <- as.data.frame(cbind((c(data_d)==1), c(data_x), c(data_x)^2))
names(logitdata) <- c("repair","mileage","mileage2")
# Estimate the logit model
logitres <- glm(repair ~ mileage + mileage2, family = binomial(link = "logit"), data = logitdata)
logitpar <- logitres$coef
# Predicted values for each state
#temp <- logitpar[1] + logitpar[2]*X
temp <- logitpar[1] + logitpar[2]*X + logitpar[3]*X^2
ccp_hat <- exp(temp) / (1+exp(temp))
# True CCPs
flow = cbind( rep(0,length(X)), theta[1] +theta[2]*(0:(length(X)-1)) )
ccp_tru <- valuemap(flow=flow,F1=F1,F2=F2,X=X,beta=beta)$ccp
# Starting values
theta_cand <- theta
# Will impose bounds to avoid extreme parameters
theta_cand_lower <- c(1, -0.20)
theta_cand_upper <- c(3, -0.10)
# Converges to lower bounds
opt_CCP <- optim(theta_cand, f_CCP_EST, busdata=busdata, F1=F1, F2=F2, X=X, beta=beta, ccp_hat=ccp_hat,
method = "L-BFGS-B", lower = theta_cand_lower, upper = theta_cand_upper)
print(opt_CCP)
# Evaluating objective function for visual on convergence
f_CCP_EST(theta_cand=theta*0.8,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*0.9,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*1.0,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*1.1,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
f_CCP_EST(theta_cand=theta*1.2,busdata=busdata,F1=F1,F2=F2,X=X,beta=beta,ccp_hat=ccp_hat)
##########################################################################
# here we start with the code for question 3
theta_hat <- minimum_distance_estimator(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len)
print(theta_hat)
theta_hat <- c(0,0)
u2_theta <- function(theta, x) {
theta[1] + theta[2] * x
}
objective <- function(theta, u2_hat, x) {
u2_model <- u2_theta(theta, x)
diff <- matrix(u2_model - u2_hat, ncol=1)
return(t(diff) %*% diff)
}
minimum_distance_estimator<- function(F1,F2,beta,ccp_hat,x_len){
gamma <- 0.5772  # actually it is not needed. It cancels out
Psi1 <- gamma - log(ccp_hat)
Psi2 <- gamma - log(1-ccp_hat)
u1 <- rep(0, x_len)  # utility for choice 1 set to 0
I <- diag(x_len)
inv_term <- solve(I - beta * F1)
u2_hat <- Psi1-Psi2 - u1 + beta * (F1 - F2) %*% inv_term %*% (Psi1 + u1)
#calculate the weighting matrix
#initial_theta <- c(1, -0.1)  # initial guess for theta
result <- optim(par = c(1, -1),
fn = objective,
u2_hat = u2_hat, x = x)
theta_hat <- result$par
return(theta_hat)
}
theta_hat <- minimum_distance_estimator(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len)
print(theta_hat)
print(data_x_index)
minimum_distance_estimator<- function(F1,F2,beta,ccp_hat,x_len){
gamma <- 0.5772  # actually it is not needed. It cancels out
Psi1 <- gamma - log(ccp_hat)
Psi2 <- gamma - log(1-ccp_hat)
u1 <- rep(0, x_len)  # utility for choice 1 set to 0
I <- diag(x_len)
inv_term <- solve(I - beta * F1)
u2_hat <- Psi1-Psi2 - u1 + beta * (F1 - F2) %*% inv_term %*% (Psi1 + u1)
#calculate the weighting matrix
w<- calculate_weighting_matrix(F1, F2, beta, x_len)
#initial_theta <- c(1, -0.1)  # initial guess for theta
result <- optim(par = c(1, -1),
fn = objective,
u2_hat = u2_hat, x = x)
theta_hat <- result$par
return(theta_hat)
}
theta_hat <- minimum_distance_estimator(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len)
View(data_t)
View(data_x_index)
total_observations<-N
#calculate total how many times does each state appear within the data
states_used <- as.vector(data_x_index)
state_counts <- table(factor(states_used, levels = 1:x_len))
weight_vector <- as.numeric(state_counts) / length(states_used)
W <- diag(weight_vector)
print(W)
total_observations<-N*T  # total number of observations
total_observations<-N*T  # total number of observations
#calculate total how many times does each state appear within the data
states_used <- as.vector(data_x_index)
state_counts <- table(factor(states_used, levels = 1:x_len))
weight_vector <- as.numeric(state_counts) / length(states_used)
W <- diag(weight_vector)
print(state_counts)
print(states_used)
#calculate total how many times does each state appear within the data
states_used <- as.vector(data_x_index)
state_counts <- table(factor(states_used, levels = 1:x_len))
weight_vector <- as.numeric(state_counts) / length(states_used)
print(states_used)
print(length(states_used))
objective <- function(theta, u2_hat, x, W) {
u2_model <- u2_theta(theta, x)  # Model-implied utility for "no repair"
diff <- matrix(u2_model - u2_hat, ncol = 1)  # Ensure it's a column vector
return(t(diff) %*% W %*% diff)  # Weighted quadratic loss
}
u2_theta <- function(theta, x) {
theta[1] + theta[2] * x
}
u2_theta <- function(theta, x) {
theta[1] + theta[2] * x
}
objective <- function(theta, u2_hat, x, W) {
u2_model <- u2_theta(theta, x)  # Model-implied utility for "no repair"
diff <- matrix(u2_model - u2_hat, ncol = 1)  # Ensure it's a column vector
return(t(diff) %*% W %*% diff)  # Weighted quadratic loss
}
calculate_weighting_matrix <- function(F1, F2, beta, x_len) {
#calculate total how many times does each state appear within the data
states_used <- as.vector(data_x_index)
state_counts <- table(factor(states_used, levels = 1:x_len))
weight_vector <- as.numeric(state_counts) / length(states_used)
W <- diag(weight_vector)
return(W)
}
minimum_distance_estimator<- function(F1,F2,beta,ccp_hat,x_len){
gamma <- 0.5772  # actually it is not needed. It cancels out
Psi1 <- gamma - log(ccp_hat)
Psi2 <- gamma - log(1-ccp_hat)
u1 <- rep(0, x_len)  # utility for choice 1 set to 0
I <- diag(x_len)
inv_term <- solve(I - beta * F1)
u2_hat <- Psi1-Psi2 - u1 + beta * (F1 - F2) %*% inv_term %*% (Psi1 + u1)
#calculate the weighting matrix
W<- calculate_weighting_matrix(F1, F2, beta, x_len)
#initial_theta <- c(1, -0.1)  # initial guess for theta
result <- optim(par = c(1.5, -0.15),
fn = objective,
u2_hat = u2_hat,
x = x,
W = W,
method = "L-BFGS-B",
lower = theta_cand_lower,
upper = theta_cand_upper)
theta_hat <- result$par
return(theta_hat)
}
theta_hat <- minimum_distance_estimator(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len)
print(theta_hat)
minimum_distance_estimator<- function(F1,F2,beta,ccp_hat,x_len){
gamma <- 0.5772  # actually it is not needed. It cancels out
Psi1 <- gamma - log(ccp_hat)
Psi2 <- gamma - log(1-ccp_hat)
u1 <- rep(0, x_len)  # utility for choice 1 set to 0
I <- diag(x_len)
inv_term <- solve(I - beta * F1)
u2_hat <- Psi1-Psi2 - u1 + beta * (F1 - F2) %*% inv_term %*% (Psi1 + u1)
#calculate the weighting matrix
W<- calculate_weighting_matrix(F1, F2, beta, x_len)
#initial_theta <- c(1, -0.1)  # initial guess for theta
result <- optim(par = c(1.5, -0.15),
fn = objective,
u2_hat = u2_hat,
x = x,
W = W)
theta_hat <- result$par
return(theta_hat)
}
theta_hat <- minimum_distance_estimator(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len)
print(theta_hat)
minimum_distance_estimator<- function(F1,F2,beta,ccp_hat,x_len){
gamma <- 0.5772  # actually it is not needed. It cancels out
Psi1 <- gamma - log(ccp_hat)
Psi2 <- gamma - log(1-ccp_hat)
u1 <- rep(0, x_len)  # utility for choice 1 set to 0
I <- diag(x_len)
inv_term <- solve(I - beta * F1)
u2_hat <- Psi1-Psi2 - u1 + beta * (F1 - F2) %*% inv_term %*% (Psi1 + u1)
#calculate the weighting matrix
W<- calculate_weighting_matrix(F1, F2, beta, x_len)
#initial_theta <- c(1, -0.1)  # initial guess for theta
result <- optim(par = c(1.5, -0.15),
fn = objective,
u2_hat = u2_hat,
x = x,
W = W)
theta_hat <- result$par
return(theta_hat)
}
theta_hat <- minimum_distance_estimator(F1=F1, F2=F2, beta=beta, ccp_hat=ccp_hat, x_len=x_len)
print(theta_hat)
